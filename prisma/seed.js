const { Pool } = require('pg');
const { PrismaPg } = require('@prisma/adapter-pg');
const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const path = require('path');

const connectionString = process.env.DATABASE_URL;
const pool = new Pool({ connectionString });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

async function main() {
    console.log('Start seeding...');

    // Load data
    const projects = JSON.parse(fs.readFileSync(path.join(__dirname, '../_legacy_backup/mock/data/projects.json'), 'utf-8'));
    const skills = JSON.parse(fs.readFileSync(path.join(__dirname, '../_legacy_backup/mock/data/skills.json'), 'utf-8'));
    const experience = JSON.parse(fs.readFileSync(path.join(__dirname, '../_legacy_backup/mock/data/work-experience.json'), 'utf-8'));
    const personalInfo = JSON.parse(fs.readFileSync(path.join(__dirname, '../_legacy_backup/mock/data/personal-info.json'), 'utf-8'));

    // Clear existing data (optional, but good for idempotent seeding)
    // Note: Use deleteMany for safety
    await prisma.project.deleteMany();
    await prisma.skill.deleteMany();
    await prisma.workExperience.deleteMany();
    await prisma.personalInfo.deleteMany();

    // Insert Personal Info
    if (personalInfo.length > 0) {
        console.log('Seeding PersonalInfo...');
        const info = personalInfo[0];
        // Remove ID to let DB autogenerate or handle logic if ID is string
        const { id, ...infoData } = info;
        // Since ID in JSON is 'default', but schema probably uses CUID/UUID or Int, let's see schema.
        // Assuming autogenerated ID or we can specific ID if needed.
        // For simplicity, we create without ID if it's autogenerated, or use it if schema allows.
        // Let's rely on create.
        await prisma.personalInfo.create({ data: infoData });
    }

    // Insert Projects
    console.log(`Seeding ${projects.length} Projects...`);
    for (const p of projects) {
        const { id, ...pData } = p;
        // Ensure json fields are stringified if schema expects string, or object if Json type
        // The JSON data has stringified JSON for arrays like "technologies": "[\"Next.js\", ...]"
        // If the schema expects JSON type, we might need to JSON.parse it?
        // Let's check schema. Old schema used `technologies String?` (text) or `Json`?
        // Legacy projects.json has "technologies": "[\"... \"]" which is a STRING of a JSON array.
        // If schema has `technologies` as `String`, we are good.
        // If `Json`, we need to parse it.
        // I'll assume schema matches legacy, so String is likely.
        await prisma.project.create({ data: pData });
    }

    // Insert Skills
    console.log(`Seeding ${skills.length} Skills...`);
    for (const s of skills) {
        const { id, ...sData } = s;
        await prisma.skill.create({ data: sData });
    }

    // Insert WorkExperience
    console.log(`Seeding ${experience.length} WorkExperience...`);
    for (const w of experience) {
        const { id, ...wData } = w;
        await prisma.workExperience.create({ data: wData });
    }

    console.log('Seeding finished.');
}

main()
    .catch((e) => {
        console.error(e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });
